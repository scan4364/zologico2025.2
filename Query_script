-- Codigo Gabriel Fonseca
ALTER TABLE Funcionario
ADD COLUMN email VARCHAR2;

CREATE UNIQUE INDEX idx_email ON Funcionario (email);

INSERT INTO Funcionario
VALUES (100,1000,200,2020-05-02,"Faxineiro",5000.00);

UPDATE Funcionario
SET email = josedafaxina@yahoo.com
WHERE id_pes = 100;

SELECT email FROM Funcionario
WHERE email LIKE 'j%';

SELECT tipo, salario FROM Funcionario
WHERE salario >= 4000;

SELECT email, salario FROM Funcionario
WHERE salario >= (SELECT AVG(salario) FROM Funcionario);

SELECT email FROM Funcionario
WHERE id_pes IN (
  SELECT id_pes
  FROM Funcionario
  WHERE tipo = 'Faxineiro'
);

DELETE FROM Funcionario
WHERE id_pes = 100;

SELECT FROM Funcionario
WHERE salario > ANY (SELECT salario FROM Funcionario WHERE data_admissao < 2025-01-01);

SELECT FROM Funcionario
WHERE salario > ALL (SELECT salario FROM Funcionario WHERE data_admissao > 2020-01-31);
-- END Codigo Gabriel Fonseca

-- Codigo celso Anjos
CREATE TABLE Audi_Funci(
    audi_id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	funId INT,
    nome VARCHAR2(255),
	data_aud DATE 
);

SELECT *
FROM Ingresso
WHERE TO_CHAR(data, 'YYYY') LIKE '2025';

SELECT 
    a.id_animal,
    a.nome AS nome_animal,
    h.cod AS habitat_id,
    h.nome AS habitat_nome
FROM Animal a
LEFT JOIN Habitat h ON a.id_habitat = h.cod;

ALTER TABLE Audi_Funci
ADD descricao VARCHAR2(255);

CREATE VIEW Audi_Funci_Hora AS 
	SELECT 
		F.id_pes AS id_pes,
		P.nome AS nome, 
		SYSDATE AS data_hora_acesso 
		FROM Funcionario F
		INNER JOIN Pessoa P ON F.id_pes = P.id_pessoa; 
    

INSERT INTO Audi_Funci(funId, nome, data_aud) 
	SELECT 
    	id_pes,
    	nome,
    	data_hora_acesso
    FROM Audi_Funci_Hora;

CREATE OR REPLACE TRIGGER trg_audi_funci_all
AFTER INSERT OR UPDATE OR DELETE ON Funcionario
FOR EACH ROW
BEGIN

  IF INSERTING THEN
    INSERT INTO Audi_Funci(funId, nome, data_aud, descricao)
    VALUES(
      :NEW.id_pes,
      NVL((SELECT nome FROM Pessoa WHERE id_pessoa = :NEW.id_pes), 'NOME_NAO_ENCONTRADO'),
      SYSDATE,
      'INSERT'
    );
  END IF;

  IF UPDATING THEN
    INSERT INTO Audi_Funci(funId, nome, data_aud, descricao)
    VALUES(
      :NEW.id_pes,
      NVL((SELECT nome FROM Pessoa WHERE id_pessoa = :NEW.id_pes), 'NOME_NAO_ENCONTRADO'),
      SYSDATE,
      'UPDATE'
    );
  END IF;

  IF DELETING THEN
    INSERT INTO Audi_Funci(funId, nome, data_aud, descricao)
    VALUES(
      :OLD.id_pes,
      NVL((SELECT nome FROM Pessoa WHERE id_pessoa = :OLD.id_pes), 'NOME_NAO_ENCONTRADO'),
      SYSDATE,
      'DELETE'
    );
  END IF;
END;
/

SELECT nome from Pessoa P
	INNER JOIN Funcionario V ON P.id_pessoa = V.id_pes
	ORDER BY nome ASC;

SELECT COUNT(*) FROM Animal 
	GROUP BY idade
	HAVING COUNT(*) < 1;

SELECT COUNT(*) AS Quatidade FROM Animal 

SELECT 'Mais Velho' AS tipo, nome, data_nascimento
FROM Pessoa
WHERE data_nascimento = (SELECT MIN(data_nascimento) FROM Pessoa)
UNION ALL
SELECT 'Mais Novo' AS tipo, nome, data_nascimento
FROM Pessoa
WHERE data_nascimento = (SELECT MAX(data_nascimento) FROM Pessoa); 

SELECT 
    AVG(TRUNC(MONTHS_BETWEEN(SYSDATE, data_nascimento) / 12)) AS idade_media
FROM Pessoa;

SELECT *
FROM Ingresso
WHERE 
    data_compra BETWEEN DATE '2024-01-01' AND DATE '2024-12-31'
    AND forma_pagamento IN (
        SELECT forma_pagamento
        FROM Ingresso
        WHERE forma_pagamento IN ('Dinheiro', 'Cartão', 'PIX')
    );

SELECT forma_pagamento, COUNT(*) AS total_vendas
FROM Ingresso
GROUP BY forma_pagamento

CREATE OR REPLACE TYPE tipo_animal_record AS OBJECT (
    id_animal   NUMBER,
    nome        VARCHAR2(255),
    habitat     VARCHAR2(255)
);
/


CREATE OR REPLACE TYPE tipo_animais_table AS TABLE OF tipo_animal_record;
/


CREATE OR REPLACE FUNCTION fn_qtd_animais_habitat(p_id_habitat NUMBER)
RETURN NUMBER
IS
    v_qtd NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_qtd FROM Animal WHERE id_habitat = p_id_habitat;
    RETURN v_qtd;
END;
/

CREATE OR REPLACE PROCEDURE prc_listar_animais_por_habitat(
    p_id_habitat IN NUMBER,
    p_result OUT tipo_animais_table
)
IS
BEGIN
    p_result := tipo_animais_table(); 

    FOR reg IN (
        SELECT a.id_animal, a.nome AS nome_animal, h.nome AS nome_habitat
        FROM Animal a
        LEFT JOIN Habitat h ON a.id_habitat = h.cod
        WHERE a.id_habitat = p_id_habitat
    ) LOOP
        p_result.EXTEND;
        p_result(p_result.LAST) := tipo_animal_record(reg.id_animal, reg.nome_animal, reg.nome_habitat);
    END LOOP;
END;
/
HAVING COUNT(*) < 2;

SELECT *
FROM Ingresso
WHERE data IS NOT NULL;

-- ==========================================================
-- ADIÇÕES: CONSULTAS USANDO CASE WHEN
-- ==========================================================

-- Classificar Funcionários por Faixa Salarial
-- ----------------------------------------------------------
-- Mostra o nome do funcionário, salário e sua faixa salarial.
SELECT 
    P.nome AS nome_funcionario,
    F.salario,
    CASE 
      WHEN F.salario >= 8000 THEN 'Alto'
      WHEN F.salario BETWEEN 8000 AND 4000 THEN 'Medio'
      ELSE 'Baixo'
    END AS faixa_salarial
FROM Funcionario F
INNER JOIN Pessoa P ON F.id_pes = P.id_pessoa;

-- Classificar Animais por Faixa Etária
-- ----------------------------------------------------------
-- Mostra o nome do animal e sua idade.
SELECT 
    A.nome AS nome_animal,
    A.idade,
    CASE 
      WHEN A.idade <= 2 THEN 'Jovem'
      WHEN A.idade BETWEEN 2 AND 10 THEN 'Adulto'
      ELSE 'Idoso'
    END AS faixa_etaria
FROM Animal A;

-- Classificar Estágios por Status Atual
-- ----------------------------------------------------------
-- Indica se um estágio está ativo, finalizado ou em andamento.
SELECT 
    E.cod,
    P.nome AS nome_estagiario,
    E.data_inicio,
    E.data_fim,
    CASE 
      WHEN E.data_fim IS NULL THEN 'Em Andamento'
      WHEN E.data_fim < SYSDATE THEN 'Finalizado'
      ELSE 'Ativo'
    END AS status_estagio
FROM Estagio E
INNER JOIN Estagiario ES ON E.id_estagiario = ES.id_func
INNER JOIN Pessoa P ON F.id_func = P.id_pessoa;

-- Classificar Ingressos por Faixa de Valor
-- ----------------------------------------------------------
-- Mostra o tipo de pagamento e classifica os ingressos conforme o valor.
SELECT 
    I.cod AS codigo_ingresso,
    I.forma_pagamento,
    I.valor,
    CASE
        WHEN I.valor < 30 THEN 'Baixo Custo'
        WHEN I.valor BETWEEN 30 AND 60 THEN 'Médio Custo'
        ELSE 'Alto Custo'
    END AS faixa_preco
FROM Ingresso I
ORDER BY I.valor;

-- Determinar a situação da supervisão do Funcionário
-- ----------------------------------------------------------
-- Mostra se o funcionário possui ou não supervisor.
SELECT 
    P.nome AS nome_funcionario,
    CASE 
      WHEN F.id_supervisor IS NULL THEN 'Sem supervisor'
      ELSE 'Com supervisor'
    END AS situacao_supervisao
FROM Funcionario F
INNER JOIN Pessoa P ON F.id_pes = P.id_pessoa
ORDER BY situacao_supervisao;


-- Código Mariana

 -- Exception WHEN
CREATE OR REPLACE FUNCTION fn_qtd_animais_habitat_seguro(p_id_habitat NUMBER)
RETURN NUMBER
IS
  v_qtd NUMBER := 0;
BEGIN
  SELECT COUNT(*) INTO v_qtd
  FROM Animal
  WHERE id_habitat = p_id_habitat;

  RETURN v_qtd;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN 0;
  WHEN OTHERS THEN
    RAISE_APPLICATION_ERROR(-20001, 'Erro inesperado em fn_qtd_animais_habitat_seguro: ' || SQLERRM);
END;
/

-- USO DE PARÂMETROS IN / OUT / IN OUT

CREATE OR REPLACE PROCEDURE prc_atualiza_salario(
  p_id_pes      IN  NUMBER,
  p_novo_salario IN NUMBER,
  p_salario_antigo OUT NUMBER,
  p_contador IN OUT NUMBER
)
IS
BEGIN
  -- pega salario antigo
  SELECT salario INTO p_salario_antigo FROM Funcionario WHERE id_pes = p_id_pes;

  -- atualiza salario
  UPDATE Funcionario
  SET salario = p_novo_salario
  WHERE id_pes = p_id_pes;

  IF SQL%ROWCOUNT = 0 THEN
    RAISE_APPLICATION_ERROR(-20002, 'Funcionario nao encontrado: ' || p_id_pes);
  END IF;

  -- incrementa contador de operações na sessão (IN OUT)
  p_contador := NVL(p_contador, 0) + 1;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- excecao tratada (reuso do exception
    p_salario_antigo := NULL;
    RAISE_APPLICATION_ERROR(-20003, 'Sem salario anterior: ' || p_id_pes);
  WHEN OTHERS THEN
    RAISE;
END;
/

-- CREATE OR REPLACE PACKAGE (CHECK 17) & PACKAGE BODY (CHECK 18)

-- CHECK 17: package spec
CREATE OR REPLACE PACKAGE zoo_pkg IS

  -- função que retorna quantidade de animais por habitat
  FUNCTION fn_qtd_animais_habitat_pkg(p_id_habitat NUMBER) RETURN NUMBER;

  -- procedimento para listar animais por habitat (usa tipo já criado tipo_animais_table)
  PROCEDURE prc_listar_animais_por_habitat_pkg(
    p_id_habitat IN NUMBER,
    p_result OUT tipo_animais_table
  );

  -- procedimento para atualizar salario (usa IN, OUT, IN OUT)
  PROCEDURE prc_atualiza_salario_pkg(
    p_id_pes IN NUMBER,
    p_novo_salario IN NUMBER,
    p_salario_antigo OUT NUMBER,
    p_contador IN OUT NUMBER
  );

END zoo_pkg;
/

-- CHECK 18: package body
CREATE OR REPLACE PACKAGE BODY zoo_pkg IS

  FUNCTION fn_qtd_animais_habitat_pkg(p_id_habitat NUMBER) RETURN NUMBER IS
    v_qtd NUMBER := 0;
  BEGIN
    SELECT COUNT(*) INTO v_qtd FROM Animal WHERE id_habitat = p_id_habitat;
    RETURN v_qtd;
  EXCEPTION
    WHEN OTHERS THEN
      -- CHECK 15: tratamento de exceção dentro do package body
      RAISE_APPLICATION_ERROR(-20010, 'Erro em fn_qtd_animais_habitat_pkg: ' || SQLERRM);
  END fn_qtd_animais_habitat_pkg;

  PROCEDURE prc_listar_animais_por_habitat_pkg(
    p_id_habitat IN NUMBER,
    p_result OUT tipo_animais_table
  ) IS
  BEGIN
    p_result := tipo_animais_table();
    FOR reg IN (
      SELECT a.id_animal, a.nome AS nome_animal, h.nome AS nome_habitat
      FROM Animal a
      LEFT JOIN Habitat h ON a.id_habitat = h.cod
      WHERE a.id_habitat = p_id_habitat
    ) LOOP
      p_result.EXTEND;
      p_result(p_result.LAST) := tipo_animal_record(reg.id_animal, reg.nome_animal, reg.nome_habitat);
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR(-20011, 'Erro em prc_listar_animais_por_habitat_pkg: ' || SQLERRM);
  END prc_listar_animais_por_habitat_pkg;

  PROCEDURE prc_atualiza_salario_pkg(
    p_id_pes IN NUMBER,
    p_novo_salario IN NUMBER,
    p_salario_antigo OUT NUMBER,
    p_contador IN OUT NUMBER
  ) IS
  BEGIN
    SELECT salario INTO p_salario_antigo FROM Funcionario WHERE id_pes = p_id_pes;

    UPDATE Funcionario
    SET salario = p_novo_salario
    WHERE id_pes = p_id_pes;

    IF SQL%ROWCOUNT = 0 THEN
      RAISE_APPLICATION_ERROR(-20012, 'Funcionario nao encontrado: ' || p_id_pes);
    END IF;

    p_contador := NVL(p_contador,0) + 1;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      p_salario_antigo := NULL;
      RAISE_APPLICATION_ERROR(-20013, 'Sem salario anterior (pkg): ' || p_id_pes);
    WHEN OTHERS THEN
      RAISE;
  END prc_atualiza_salario_pkg;

END zoo_pkg;
/

-- CHECK 19: trigger que valida e audita Ingresso
CREATE OR REPLACE TRIGGER trg_ingresso_valida
BEFORE INSERT OR UPDATE ON Ingresso
FOR EACH ROW
DECLARE
  v_msg VARCHAR2(4000);
BEGIN
  -- valida quantidade
  IF :NEW.quantidade IS NULL OR :NEW.quantidade <= 0 THEN
    v_msg := 'Quantidade invalida em Ingresso: ' || NVL(TO_CHAR(:NEW.quantidade), 'NULL');
    RAISE_APPLICATION_ERROR(-20020, v_msg);
  END IF;

  -- valida valor
  IF :NEW.valor IS NULL OR :NEW.valor <= 0 THEN
    v_msg := 'Valor invalido em Ingresso: ' || NVL(TO_CHAR(:NEW.valor), 'NULL');
    RAISE_APPLICATION_ERROR(-20021, v_msg);
  END IF;

  -- Exemplo de log: inserir em tabela de auditoria (se existir)
  BEGIN
    INSERT INTO Audi_Funci(funId, nome, data_aud, descricao)
    VALUES(
      :NEW.id_atendente, -- como exemplo, usamos id_atendente como user
      (SELECT nome FROM Pessoa WHERE id_pessoa = :NEW.id_atendente),
      SYSDATE,
      CASE
        WHEN INSERTING THEN 'INSERCAO_INGRESSO'
        WHEN UPDATING THEN 'ATUALIZACAO_INGRESSO'
        ELSE 'OUTRO'
      END
    );
  EXCEPTION
    WHEN OTHERS THEN
      
      NULL; 
  END;

END;
/
-- ==========================================================
--      ADIÇÕES: FUNÇÕES PRÁTICAS COM LOOP EXIT WHEN 
-- ==========================================================

-- Função: Somar salários de todos os funcionários até atingir um limite
CREATE OR REPLACE FUNCTION fn_somar_salarios_ate_limite(p_limite NUMBER)
RETURN NUMBER
IS
    v_total NUMBER := 0;
    v_salario NUMBER;
    CURSOR c_sal IS SELECT salario FROM Funcionario ORDER BY salario;
BEGIN
    OPEN c_sal;
    LOOP
        FETCH c_sal INTO v_salario;
        EXIT WHEN c_sal%NOTFOUND; -- Sai do loop se acabar o cursor
        v_total := v_total + v_salario;
        EXIT WHEN v_total >= p_limite; -- Sai do loop se acabar o cursor
    END LOOP;
END;

-- Função: Contar quantos funcionários têm salário acima de um valor,
--             parando a contagem quando encontrar 5 registros (para eficiência)
CREATE OR REPLACE FUNCTION fn_contar_funcionarios_acima(p_valor NUMBER)
RETURN NUMBER
IS
    v_count NUMBER := 0;
    v_salario NUMBER;
    CURSOR c_func IS SELECT salario FROM Funcionario WHERE salario > p_valor;
BEGIN
    OPEN c_func;
    LOOP
        FETCH c_func INTO v_salario;
        EXIT WHEN c_func%NOTFOUND;
        v_count := v_count + 1;
        EXIT WHEN v_count >= 5; -- Para o loop após 5 registros
    END LOOP;
    CLOSE c_func;
    RETURN v_count;
END;

-- 3️ Função: Retornar a soma de idades das pessoas até atingir 200 anos acumulados
CREATE OR REPLACE FUNCTION fn_somar_idades
RETURN NUMBER
IS
    v_total_idade NUMBER := 0;
    v_idade NUMBER;
    CURSOR c_pessoas IS SELECT TRUNC(MONTHS_BETWEEN(SYSDATE, data_nascimento)/12) AS idade FROM Pessoa;
BEGIN
    OPEN c_pessoas;
    LOOP
        FETCH c_pessoas INTO v_idade;
        EXIT WHEN c_pessoas%NOTFOUND;
        v_total_idade := v_total_idade + v_idade;
        EXIT WHEN v_total_idade >= 200;
    END LOOP;
    CLOSE c_pessoas;
    RETURN v_total_idade;
END;

-- Função: Procurar e retornar o primeiro e-mail de funcionário que comece com certa letra
CREATE OR REPLACE FUNCTION fn_primeiro_email_inicial(p_inicial CHAR)
RETURN VARCHAR2
IS
    v_email VARCHAR2(255);
    CURSOR c_email IS SELECT email FROM Funcionario WHERE email LIKE p_inicial || '%';
BEGIN
    OPEN c_email;
    LOOP
        FETCH c_email INTO v_email;
        EXIT WHEN c_email%NOTFOUND OR v_email IS NOT NULL; -- Sai quando achar o primeiro
    END LOOP;
    CLOSE c_email;
    RETURN v_email;
END;

-- Função: Calcular total de vendas de ingressos até determinado ano, parando ao atingir o limite
CREATE OR REPLACE FUNCTION fn_total_vendas_ate_ano(p_ano NUMBER, p_limite NUMBER)
RETURN NUMBER
IS
    v_total NUMBER := 0;
    v_valor NUMBER;
    v_ano   NUMBER;
    CURSOR c_ing IS SELECT valor_total, EXTRACT(YEAR FROM data_compra) AS ano FROM Ingresso;
BEGIN
    OPEN c_ing;
    LOOP
        FETCH c_ing INTO v_valor, v_ano;
        EXIT WHEN c_ing%NOTFOUND;
        IF v_ano <= p_ano THEN
            v_total := v_total + v_valor;
        END IF;
        EXIT WHEN v_total >= p_limite; -- Sai se atingir o teto
    END LOOP;
    CLOSE c_ing;
    RETURN v_total;
END;

